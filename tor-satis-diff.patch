diff --git a/src/or/config.c b/src/or/config.c
index 73cc7c273..5c8b3822e 100644
--- a/src/or/config.c
+++ b/src/or/config.c
@@ -387,6 +387,10 @@ static config_var_t option_vars_[] = {
   VAR("HiddenServiceOptions",LINELIST_V, RendConfigLines,    NULL),
   VAR("HiddenServicePort",   LINELIST_S, RendConfigLines,    NULL),
   VAR("HiddenServiceVersion",LINELIST_S, RendConfigLines,    NULL),
+  VAR("HiddenServiceSatisSig", LINELIST_S, RendConfigLines, NULL),
+  VAR("HiddenServiceSatisDomain", LINELIST_S, RendConfigLines, NULL),
+  VAR("HiddenServiceSatisFingerprint", LINELIST_S, RendConfigLines, NULL),
+  VAR("HiddenServiceSatisSigInterval", LINELIST_S, RendConfigLines, NULL),
   VAR("HiddenServiceAuthorizeClient",LINELIST_S,RendConfigLines, NULL),
   VAR("HiddenServiceAllowUnknownPorts",LINELIST_S, RendConfigLines, NULL),
   VAR("HiddenServiceMaxStreams",LINELIST_S, RendConfigLines, NULL),
diff --git a/src/or/hs_common.h b/src/or/hs_common.h
index 7c5ea4792..d0369b924 100644
--- a/src/or/hs_common.h
+++ b/src/or/hs_common.h
@@ -23,6 +23,10 @@
 #define HS_VERSION_MIN HS_VERSION_TWO
 #define HS_VERSION_MAX HS_VERSION_THREE
 
+#define SATIS_SIG_INTERVAL_MIN 60
+#define SATIS_SIG_INTERVAL_DEF 60*60*24
+#define SATIS_SIG_INTERVAL_MAX 60*60*24*3
+
 /** Try to maintain this many intro points per service by default. */
 #define NUM_INTRO_POINTS_DEFAULT 3
 /** Maximum number of intro points per generic and version 2 service. */
diff --git a/src/or/hs_config.c b/src/or/hs_config.c
index fa5c1ab17..92cffc526 100644
--- a/src/or/hs_config.c
+++ b/src/or/hs_config.c
@@ -354,6 +354,36 @@ config_generic_service(const config_line_t *line_,
       have_version = 1;
       continue;
     }
+    if (!strcasecmp(line->key, "HiddenServiceSatisSig")) {
+      config->do_satis_sig =
+        (unsigned int) helper_parse_uint64(line->key, line->value, 0, 1, &ok);
+      if (!ok) {
+        log_warn(LD_CONFIG, "Couldn't parse HiddenServiceSatisSig value %s",
+            line->value);
+      }
+      continue;
+    }
+    if (!strcasecmp(line->key, "HiddenServiceSatisSigInterval")) {
+        config->satis_interval =
+            (unsigned int) helper_parse_uint64(line->key, line->value,
+                    SATIS_SIG_INTERVAL_MIN, SATIS_SIG_INTERVAL_MAX, &ok);
+        if (!ok) {
+            log_warn(LD_CONFIG, "Couldn't parse HiddenServiceSatisSigInterval "
+                   "value %s", line->value);
+        }
+        continue;
+    }
+    if (!strcasecmp(line->key, "HiddenServiceSatisDomain")) {
+      config->satis_domain = tor_strdup(line->value);
+      log_info(LD_CONFIG, "HiddenService with domain %s", line->value);
+      continue;
+    }
+    if (!strcasecmp(line->key, "HiddenServiceSatisFingerprint")) {
+      config->satis_fingerprint = tor_strdup(line->value);
+      log_info(LD_CONFIG, "HiddenService with TLS fingerprint %s",
+          line->value);
+      continue;
+    }
     /* Virtual port. */
     if (!strcasecmp(line->key, "HiddenServicePort")) {
       char *err_msg = NULL;
@@ -439,6 +469,10 @@ config_generic_service(const config_line_t *line_,
     }
   }
 
+  if (!config->satis_interval) {
+      config->satis_interval = SATIS_SIG_INTERVAL_DEF;
+  }
+
   /* Success */
   return 0;
  err:
diff --git a/src/or/hs_service.c b/src/or/hs_service.c
index 45810c5c5..c676466f7 100644
--- a/src/or/hs_service.c
+++ b/src/or/hs_service.c
@@ -66,6 +66,11 @@
 /* Onion service directory file names. */
 static const char fname_keyfile_prefix[] = "hs_ed25519";
 static const char fname_hostname[] = "hostname";
+static const char fname_satis_sig[] = "satis_sig";
+static const char fname_satis_sig_bad_fp[] = "satis_sig_bad_fp";
+static const char fname_satis_sig_bad_time[] = "satis_sig_bad_time";
+static const char fname_satis_sig_bad_domain[] = "satis_sig_bad_domain";
+static const char fname_satis_sig_bad_sig[] = "satis_sig_bad_sig";
 static const char address_tld[] = "onion";
 
 /* Staging list of service object. When configuring service, we add them to
@@ -954,6 +959,261 @@ write_address_to_file(const hs_service_t *service, const char *fname_)
   return ret;
 }
 
+static int
+write_satis_sig_to_file_impl(const char *fname, uint64_t time_center,
+    uint64_t time_window, const char *domain, const char *fingerprint,
+    ed25519_keypair_t *keypair)
+{
+  int ret = -2;
+  uint8_t *msg = NULL;
+  int msg_size = 0;
+  int offset = 0;
+
+  const char magic[] = "satis-guard-----";
+  tor_assert(domain);
+  const uint32_t domain_len = (uint32_t)strlen(domain);
+  const uint32_t domain_len_net = htonl(domain_len);
+  tor_assert(fingerprint);
+  const uint32_t fingerprint_len = (uint32_t)strlen(fingerprint);
+  const uint32_t fingerprint_len_net = htonl(fingerprint_len);
+
+  const uint64_t time_center_net = tor_htonll(time_center);
+  const uint64_t time_window_net = tor_htonll(time_window);
+
+  tor_assert(fname);
+  tor_assert(keypair);
+
+  uint32_t nonce = 0;
+  crypto_rand((char*)&nonce, sizeof(nonce));
+
+  ed25519_signature_t sig;
+
+  /*
+   * magic string
+   * 64bit time of middle of validity window (seconds since 1970)
+   * 64bit width of validity window (seconds)
+   * 32bit nonce
+   * 32bit domain str length
+   * varied domain str
+   * 32bit fingerprint str lenght
+   * varied fingerprint str
+   */
+  msg_size = (int)(strlen(magic) + 2 * sizeof(uint64_t) +
+      2 * sizeof(uint32_t) + domain_len + sizeof(uint32_t) +
+      fingerprint_len + ED25519_SIG_LEN);
+  msg = tor_malloc_zero(msg_size);
+
+  memcpy(msg+offset, magic, strlen(magic));
+  offset += strlen(magic);
+  memcpy(msg+offset, &time_center_net, sizeof(time_center_net));
+  offset += sizeof(time_center_net);
+  memcpy(msg+offset, &time_window_net, sizeof(time_window_net));
+  offset += sizeof(time_window_net);
+  memcpy(msg+offset, &nonce, sizeof(nonce));
+  offset += sizeof(nonce);
+  memcpy(msg+offset, &domain_len_net, sizeof(domain_len_net));
+  offset += sizeof(domain_len_net);
+  memcpy(msg+offset, domain, domain_len);
+  offset += domain_len;
+  memcpy(msg+offset, &fingerprint_len_net, sizeof(fingerprint_len_net));
+  offset += sizeof(fingerprint_len_net);
+  memcpy(msg+offset, fingerprint, fingerprint_len);
+  offset += fingerprint_len;
+
+  tor_assert(offset + ED25519_SIG_LEN == msg_size);
+
+  ret = ed25519_sign(&sig, msg, offset, keypair);
+  if (ret != 0) {
+    log_warn(LD_REND, "Unable to sign SATIS data");
+    goto end;
+  }
+  memcpy(msg+offset, sig.sig, ED25519_SIG_LEN);
+  offset += ED25519_SIG_LEN;
+
+  tor_assert(offset == msg_size);
+
+  ret = write_bytes_to_file(fname, (const char*)msg, offset, 1);
+  if (ret != 0) {
+    log_warn(LD_REND, "Unable to write onion service SATIS signature to "
+        "file %s", escaped(fname));
+    goto end;
+  }
+
+  log_notice(LD_REND, "We%s satis sig for domain %s (%u) with TLS fp %s (%u) "
+      "to file %s",
+      ret != 0 ? " had issues when writing" : " successfully wrote",
+      domain, domain_len, fingerprint, fingerprint_len, fname);
+
+  ret = 0;
+
+end:
+  tor_free(msg);
+  return ret;
+}
+
+static int
+write_bad_fingerprint_satis_sig_to_file(hs_service_t *service)
+{
+  char *fname = hs_path_from_filename(service->config.directory_path,
+                                      fname_satis_sig_bad_fp);
+  tor_assert(service);
+  tor_assert(service->satis_last_sign + service->config.satis_interval <
+          (uint64_t)time(NULL));
+
+  int ret = -3;
+
+  const uint64_t time_center = time(NULL);
+  const uint64_t time_window = 7*24*60*60; // 7 days
+
+  const char *fingerprint = "DEADBEEF111111111111";
+
+  char *domain = NULL;
+  tor_asprintf(&domain, "%sonion.%s", service->onion_address,
+      service->config.satis_domain);
+
+  ed25519_keypair_t keypair;
+  keypair.seckey = service->keys.identity_sk;
+  keypair.pubkey = service->keys.identity_pk;
+
+  ret = write_satis_sig_to_file_impl(fname, time_center, time_window, domain,
+      fingerprint, &keypair);
+
+  tor_free(domain);
+  tor_free(fname);
+  return ret;
+}
+
+static int
+write_bad_time_satis_sig_to_file(hs_service_t *service)
+{
+  char *fname = hs_path_from_filename(service->config.directory_path,
+                                      fname_satis_sig_bad_time);
+  tor_assert(service);
+  tor_assert(service->satis_last_sign + service->config.satis_interval <
+          (uint64_t)time(NULL));
+
+  int ret = -3;
+
+  const uint64_t time_center = time(NULL) - 8*24*60*60;
+  const uint64_t time_window = 7*24*60*60; // 7 days
+
+  const char *fingerprint = service->config.satis_fingerprint;
+
+  char *domain = NULL;
+  tor_asprintf(&domain, "%sonion.%s", service->onion_address,
+      service->config.satis_domain);
+
+  ed25519_keypair_t keypair;
+  keypair.seckey = service->keys.identity_sk;
+  keypair.pubkey = service->keys.identity_pk;
+
+  ret = write_satis_sig_to_file_impl(fname, time_center, time_window, domain,
+      fingerprint, &keypair);
+
+  tor_free(domain);
+  tor_free(fname);
+  return ret;
+}
+
+static int
+write_bad_domain_satis_sig_to_file(hs_service_t *service)
+{
+  char *fname = hs_path_from_filename(service->config.directory_path,
+                                      fname_satis_sig_bad_domain);
+  tor_assert(service);
+  tor_assert(service->satis_last_sign + service->config.satis_interval <
+          (uint64_t)time(NULL));
+
+  int ret = -3;
+
+  const uint64_t time_center = time(NULL);
+  const uint64_t time_window = 7*24*60*60; // 7 days
+
+  const char *fingerprint = service->config.satis_fingerprint;
+
+  char *domain = NULL;
+  tor_asprintf(&domain, "%sonion.notmyname.com", service->onion_address);
+
+  ed25519_keypair_t keypair;
+  keypair.seckey = service->keys.identity_sk;
+  keypair.pubkey = service->keys.identity_pk;
+
+  ret = write_satis_sig_to_file_impl(fname, time_center, time_window, domain,
+      fingerprint, &keypair);
+
+  tor_free(domain);
+  tor_free(fname);
+  return ret;
+}
+
+static int
+write_bad_sig_satis_sig_to_file(hs_service_t *service)
+{
+  char *fname = hs_path_from_filename(service->config.directory_path,
+                                      fname_satis_sig_bad_sig);
+  tor_assert(service);
+  tor_assert(service->satis_last_sign + service->config.satis_interval <
+          (uint64_t)time(NULL));
+
+  int ret = -3;
+
+  const uint64_t time_center = time(NULL);
+  const uint64_t time_window = 7*24*60*60; // 7 days
+
+  const char *fingerprint = service->config.satis_fingerprint;
+
+  char *domain = NULL;
+  tor_asprintf(&domain, "%sonion.%s", service->onion_address,
+      service->config.satis_domain);
+
+  ed25519_keypair_t keypair;
+  keypair.seckey = service->keys.identity_sk;
+  keypair.seckey.seckey[0] = 0xde;
+  keypair.seckey.seckey[1] = 0xad;
+  keypair.seckey.seckey[2] = 0xbe;
+  keypair.seckey.seckey[3] = 0xef;
+  keypair.pubkey = service->keys.identity_pk;
+
+  ret = write_satis_sig_to_file_impl(fname, time_center, time_window, domain,
+      fingerprint, &keypair);
+
+  tor_free(domain);
+  tor_free(fname);
+  return ret;
+}
+
+static int
+write_good_satis_sig_to_file(hs_service_t *service)
+{
+  char *fname = hs_path_from_filename(service->config.directory_path,
+                                      fname_satis_sig);
+  tor_assert(service);
+  tor_assert(service->satis_last_sign + service->config.satis_interval <
+          (uint64_t)time(NULL));
+
+  int ret = -3;
+
+  const uint64_t time_center = time(NULL);
+  const uint64_t time_window = 7*24*60*60; // 7 days
+
+  const char *fingerprint = service->config.satis_fingerprint;
+
+  char *domain = NULL;
+  tor_asprintf(&domain, "%sonion.%s", service->onion_address,
+      service->config.satis_domain);
+
+  ed25519_keypair_t keypair;
+  keypair.seckey = service->keys.identity_sk;
+  keypair.pubkey = service->keys.identity_pk;
+
+  ret = write_satis_sig_to_file_impl(fname, time_center, time_window, domain,
+      fingerprint, &keypair);
+
+  tor_free(domain);
+  tor_free(fname);
+  return ret;
+}
+
 /* Load and/or generate private keys for the given service. On success, the
  * hostname file will be written to disk along with the master private key iff
  * the service is not configured for offline keys. Return 0 on success else -1
@@ -2643,6 +2903,39 @@ should_service_upload_descriptor(const hs_service_t *service,
   return 0;
 }
 
+static void
+run_satis_sig_event(time_t now)
+{
+    (void)now;
+    FOR_EACH_SERVICE_BEGIN(service) {
+      if (service->config.do_satis_sig &&
+              service->satis_last_sign + service->config.satis_interval <
+              (uint64_t)time(NULL)) {
+          if (write_good_satis_sig_to_file(service) < 0) {
+              log_warn(LD_REND, "Unable to sign satis sig file for %s",
+                      service->onion_address);
+          }
+          if (write_bad_time_satis_sig_to_file(service) < 0) {
+              log_warn(LD_REND, "Unable to sign bad time satis sig "
+                  "file for %s", service->onion_address);
+          }
+          if (write_bad_fingerprint_satis_sig_to_file(service) < 0) {
+              log_warn(LD_REND, "Unable to sign bad fingerprint satis sig "
+                  "file for %s", service->onion_address);
+          }
+          if (write_bad_domain_satis_sig_to_file(service) < 0) {
+              log_warn(LD_REND, "Unable to sign bad domain satis sig "
+                  "file for %s", service->onion_address);
+          }
+          if (write_bad_sig_satis_sig_to_file(service) < 0) {
+              log_warn(LD_REND, "Unable to sign bad sig satis sig "
+                  "file for %s", service->onion_address);
+          }
+          service->satis_last_sign = time(NULL);
+      }
+    } FOR_EACH_SERVICE_END;
+}
+
 /* Scheduled event run from the main loop. Try to upload the descriptor for
  * each service. */
 STATIC void
@@ -3315,6 +3608,8 @@ hs_service_run_scheduled_events(time_t now)
   run_build_circuit_event(now);
   /* Upload the descriptors if needed/possible. */
   run_upload_descriptor_event(now);
+  /* Resign satis data if needed */
+  run_satis_sig_event(now);
 }
 
 /* Initialize the service HS subsystem. */
diff --git a/src/or/hs_service.h b/src/or/hs_service.h
index ed1053d85..2d2f36250 100644
--- a/src/or/hs_service.h
+++ b/src/or/hs_service.h
@@ -156,6 +156,13 @@ typedef struct hs_service_config_t {
    * if the service is ephemeral. Specified by HiddenServiceDir option. */
   char *directory_path;
 
+  /* Domain name for SATIS stuff */
+  char *satis_domain;
+  /* TLS fingerprint for SATIS stuff */
+  char *satis_fingerprint;
+
+  uint64_t satis_interval;
+
   /* The maximum number of simultaneous streams per rendezvous circuit that
    * are allowed to be created. No limit if 0. Specified by
    * HiddenServiceMaxStreams option. */
@@ -183,6 +190,9 @@ typedef struct hs_service_config_t {
 
   /* Is this service ephemeral? */
   unsigned int is_ephemeral : 1;
+
+  /* Whether or not to sign data for SATIS */
+  unsigned int do_satis_sig : 1;
 } hs_service_config_t;
 
 /* Service state. */
@@ -232,6 +242,9 @@ typedef struct hs_service_t {
   /* Next descriptor. */
   hs_service_descriptor_t *desc_next;
 
+  /* Timestamp of the last time we generated a satis signature */
+  time_t satis_last_sign;
+
   /* XXX: Credential (client auth.) #20700. */
 
 } hs_service_t;
